# -*- coding: utf-8 -*-
"""Netflix EDA Dashboard with Gradio

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VIc6QvZWvgifjZo3oeV3HXVuM9z1XL0w
"""

import pandas as pd
import numpy as np
import gradio as gr
import plotly.express as px
import plotly.graph_objects as go
import re

# --- Data Loading and Preprocessing Function ---
def load_and_preprocess_data(file_obj):
    """
    Loads the Netflix CSV data, performs cleaning, and feature engineering.
    """
    if file_obj is None:
        return None, "Please upload a CSV file."

    try:
        df = pd.read_csv(file_obj.name)
    except Exception as e:
        return None, f"Error reading CSV: {e}"

    # Basic cleaning and feature engineering
    df['date_added'] = pd.to_datetime(df['date_added'], errors='coerce')
    df['year_added'] = df['date_added'].dt.year
    df['month_added'] = df['date_added'].dt.month_name()
    df['day_added'] = df['date_added'].dt.day
    df['release_year_cat'] = df['release_year'].astype(str) # For categorical plotting

    # Fill NaN values in 'country' and 'rating' for better analysis
    df['country'] = df['country'].fillna('Unknown')
    df['rating'] = df['rating'].fillna('Unknown')
    df['director'] = df['director'].fillna('Unknown')
    df['cast'] = df['cast'].fillna('Unknown')
    df['duration'] = df['duration'].fillna('Unknown')
    df['description'] = df['description'].fillna('') # Empty string for descriptions

    # Convert 'duration' to numeric for movies (minutes)
    df['duration_minutes'] = df['duration'].apply(
        lambda x: int(x.split(' ')[0]) if 'min' in str(x) else np.nan
    )
    return df, "Data loaded and preprocessed successfully!"

# --- Filtering Function ---
def filter_dataframe(df, content_type, selected_years, selected_countries, selected_ratings, selected_genres):
    """
    Filters the DataFrame based on user selections.
    """
    if df is None or df.empty:
        return pd.DataFrame(), "Please upload data first."

    filtered_df = df.copy()

    # Content Type Filter
    if content_type == 'Movie':
        filtered_df = filtered_df[filtered_df['type'] == 'Movie']
    elif content_type == 'TV Show':
        filtered_df = filtered_df[filtered_df['type'] == 'TV Show']

    # Release Year Filter
    if selected_years:
        filtered_df = filtered_df[(filtered_df['release_year'] >= selected_years[0]) & (filtered_df['release_year'] <= selected_years[1])]

    # Country Filter
    if selected_countries:
        # Need to handle comma-separated countries in the 'country' column
        filtered_df = filtered_df[
            filtered_df['country'].apply(lambda x: any(c.strip() in selected_countries for c in x.split(',')))
        ]

    # Rating Filter
    if selected_ratings:
        filtered_df = filtered_df[filtered_df['rating'].isin(selected_ratings)]

    # Genre Filter
    if selected_genres:
        # Need to handle comma-separated genres in the 'listed_in' column
        filtered_df = filtered_df[
            filtered_df['listed_in'].apply(lambda x: any(g.strip() in selected_genres for g in x.split(',')))
        ]
    return filtered_df, f"Filtered data: {len(filtered_df)} items."

# --- Visualization Functions (returning Plotly figures) ---
def plot_content_type_distribution(df):
    if df.empty:
        return go.Figure().update_layout(title="No data to display")
    type_counts = df['type'].value_counts()
    fig = px.pie(
        names=type_counts.index,
        values=type_counts.values,
        title='Overall Distribution of Content Types on Netflix',
        color_discrete_sequence=px.colors.qualitative.Pastel
    )
    return fig

def plot_top_countries(df):
    if df.empty:
        return go.Figure().update_layout(title="No data to display")
    country_counts = df['country'].str.split(', ').explode().value_counts()
    top_countries = country_counts.head(10)
    fig = px.bar(
        x=top_countries.index,
        y=top_countries.values,
        title='Top 10 Countries by Content Production (Filtered)',
        labels={'x': 'Country', 'y': 'Number of Titles'},
        color_discrete_sequence=px.colors.qualitative.Dark24
    )
    return fig

def plot_content_added_over_time(df):
    if df.empty or 'year_added' not in df.columns or df['year_added'].isnull().all():
        return go.Figure().update_layout(title="No data to display for Content Added Over Time")
    content_by_year_added = df['year_added'].value_counts().sort_index()
    fig = px.line(
        x=content_by_year_added.index,
        y=content_by_year_added.values,
        title='Number of Titles Added to Netflix Per Year (Filtered)',
        labels={'x': 'Year Added', 'y': 'Number of Titles'},
        markers=True,
        color_discrete_sequence=px.colors.qualitative.Set1
    )
    return fig

def plot_top_genres(df):
    if df.empty:
        return go.Figure().update_layout(title="No data to display")
    genre_counts = df['listed_in'].str.split(', ').explode().value_counts()
    top_genres = genre_counts.head(10)
    if top_genres.empty:
        return go.Figure().update_layout(title="No data to display for Top Genres/Categories")
    fig = px.bar(
        x=top_genres.index,
        y=top_genres.values,
        title='Top 10 Genres/Categories (Filtered)',
        labels={'x': 'Genre', 'y': 'Number of Titles'},
        color_discrete_sequence=px.colors.qualitative.Pastel
    )
    return fig

def plot_ratings_distribution(df):
    if df.empty:
        return go.Figure().update_layout(title="No data to display")
    rating_counts = df['rating'].value_counts().sort_index()
    fig = px.bar(
        x=rating_counts.index,
        y=rating_counts.values,
        title='Distribution of Content Ratings (Filtered)',
        labels={'x': 'Rating', 'y': 'Number of Titles'},
        color_discrete_sequence=px.colors.qualitative.Prism
    )
    return fig

def plot_movie_duration_distribution(df):
    movies_df = df[df['type'] == 'Movie']
    movie_durations = movies_df['duration_minutes'].dropna()
    if movie_durations.empty:
        return go.Figure().update_layout(title="No movie duration data to display")
    fig = px.histogram(
        movie_durations,
        nbins=30,
        title='Distribution of Movie Durations (in minutes) (Filtered)',
        labels={'value': 'Duration (minutes)', 'count': 'Number of Movies'},
        color_discrete_sequence=['#4B0082'] # Indigo color
    )
    return fig

# --- Gradio UI Layout with Blocks ---
with gr.Blocks(title="Netflix EDA Dashboard") as demo:
    # State variables to hold the full and filtered DataFrames
    full_df_state = gr.State(pd.DataFrame())
    filtered_df_state = gr.State(pd.DataFrame())

    gr.Markdown(
        """
        # ğŸ¬ Netflix Content Explorer (Gradio)
        Upload your `netflix_titles.csv` file to analyze trends, distributions, and insights from Netflix content.
        """
    )

    with gr.Row():
        with gr.Column(scale=1):
            file_upload = gr.File(label="Upload Netflix CSV File (netflix_titles.csv)")
            status_message = gr.Textbox(label="Status", interactive=False, value="Awaiting file upload...")

            # Filter controls (will be initially disabled and populated after data upload)
            content_type_radio = gr.Radio(
                ["Movie", "TV Show", "Both"],
                label="Select Content Type:",
                value="Both",
                interactive=False
            )
            release_year_slider = gr.Slider(
                minimum=1940, # Placeholder min
                maximum=2022, # Placeholder max
                value=(1940, 2022),
                label="Select Release Year Range:",
                step=1,
                interactive=False
            )
            country_multiselect = gr.CheckboxGroup(
                [],
                label="Select Country:",
                interactive=False
            )
            rating_multiselect = gr.CheckboxGroup(
                [],
                label="Select Rating:",
                interactive=False
            )
            genre_multiselect = gr.CheckboxGroup(
                [],
                label="Select Genre (Category):",
                interactive=False
            )

        with gr.Column(scale=3):
            gr.Markdown("### Filtered Data Overview")
            filtered_data_display = gr.DataFrame(interactive=False)
            filtered_count_display = gr.Textbox(label="Filtered Count", interactive=False)

            gr.Markdown("### Visual Insights")
            with gr.Tab("Content Distribution"):
                plot_type_dist = gr.Plot(label="Content Type Distribution")
                plot_rating_dist = gr.Plot(label="Ratings Distribution")
            with gr.Tab("Geographic & Time Trends"):
                plot_top_countries_chart = gr.Plot(label="Top 10 Countries by Content Production")
                plot_content_added_chart = gr.Plot(label="Content Added Over Time")
            with gr.Tab("Genres & Durations"):
                plot_top_genres_chart = gr.Plot(label="Top 10 Genres/Categories")
                plot_movie_duration_chart = gr.Plot(label="Movie Duration Distribution")


    # --- Event Handlers ---

    # This function handles the file upload, data preprocessing,
    # and initial population of filters and plots.
    def handle_file_upload(file_obj):
        df, msg = load_and_preprocess_data(file_obj)
        if df is None:
            # If data loading fails, reset components to initial disabled state
            return (
                pd.DataFrame(), # full_df_state
                pd.DataFrame(), # filtered_df_state
                msg,
                gr.Radio(interactive=False, value="Both"),
                gr.Slider(minimum=1940, maximum=2022, value=(1940, 2022), interactive=False),
                gr.CheckboxGroup(choices=[], value=[], interactive=False),
                gr.CheckboxGroup(choices=[], value=[], interactive=False),
                gr.CheckboxGroup(choices=[], value=[], interactive=False),
                pd.DataFrame(), # filtered_data_display
                "", # filtered_count_display
                go.Figure().update_layout(title="Upload data to see plot"),
                go.Figure().update_layout(title="Upload data to see plot"),
                go.Figure().update_layout(title="Upload data to see plot"),
                go.Figure().update_layout(title="Upload data to see plot"),
                go.Figure().update_layout(title="Upload data to see plot"),
                go.Figure().update_layout(title="Upload data to see plot")
            )

        # Extract unique values for filter choices
        # Splitting and exploding 'country' and 'listed_in' to get all unique individual values
        all_countries = sorted(df['country'].str.split(', ').explode().dropna().unique().tolist())
        all_ratings = sorted(df['rating'].dropna().unique().tolist())
        all_genres = sorted(df['listed_in'].str.split(', ').explode().dropna().unique().tolist())

        # Determine min/max release years for the slider
        min_year = int(df['release_year'].min()) if not df['release_year'].empty else 1940
        max_year = int(df['release_year'].max()) if not df['release_year'].empty else 2022

        # Initial filtering (all data) to populate dashboard on load
        initial_filtered_df, initial_filtered_msg = filter_dataframe(df, "Both", (min_year, max_year), [], all_ratings, [])

        # Return updated state variables and updated UI components
        return (
            df,  # full_df_state
            initial_filtered_df, # filtered_df_state
            msg,
            gr.Radio(interactive=True, value="Both"),
            gr.Slider(minimum=min_year, maximum=max_year, value=(min_year, max_year), interactive=True),
            gr.CheckboxGroup(choices=all_countries, value=[], interactive=True), # Default no countries selected
            gr.CheckboxGroup(choices=all_ratings, value=all_ratings, interactive=True), # Default all ratings selected
            gr.CheckboxGroup(choices=all_genres, value=[], interactive=True), # Default no genres selected
            initial_filtered_df.head(), # Initial filtered data display
            initial_filtered_msg,
            plot_content_type_distribution(initial_filtered_df),
            plot_ratings_distribution(initial_filtered_df),
            plot_top_countries(initial_filtered_df),
            plot_content_added_over_time(initial_filtered_df),
            plot_top_genres(initial_filtered_df),
            plot_movie_duration_distribution(initial_filtered_df)
        )

    # Trigger the handle_file_upload function when a file is uploaded
    file_upload.upload(
        handle_file_upload,
        inputs=[file_upload],
        outputs=[
            full_df_state,
            filtered_df_state,
            status_message,
            content_type_radio,
            release_year_slider,
            country_multiselect,
            rating_multiselect,
            genre_multiselect,
            filtered_data_display,
            filtered_count_display,
            plot_type_dist,
            plot_rating_dist,
            plot_top_countries_chart,
            plot_content_added_chart,
            plot_top_genres_chart,
            plot_movie_duration_chart
        ]
    )

    # Function to update all plots and filtered data based on filter changes
    def update_dashboard(
        full_df, content_type, selected_years, selected_countries, selected_ratings, selected_genres
    ):
        if full_df.empty:
            # If no data loaded, return empty states for all outputs and informative messages
            empty_fig = go.Figure().update_layout(title="Upload data first")
            return (
                pd.DataFrame(),
                pd.DataFrame(), "Upload data first to see filtered content.",
                empty_fig, empty_fig, empty_fig, empty_fig, empty_fig, empty_fig
            )

        filtered_df, msg = filter_dataframe(full_df, content_type, selected_years, selected_countries, selected_ratings, selected_genres)

        return (
            filtered_df, # Updated filtered_df_state
            filtered_df.head(), # Dataframe head display
            msg, # Filtered count message
            plot_content_type_distribution(filtered_df),
            plot_ratings_distribution(filtered_df),
            plot_top_countries(filtered_df),
            plot_content_added_over_time(filtered_df),
            plot_top_genres(filtered_df),
            plot_movie_duration_distribution(filtered_df)
        )

    # Attach update_dashboard function to all filter components' change events.
    # This ensures the dashboard updates whenever a filter value is changed.
    filter_inputs_for_change = [
        full_df_state, # Pass the full_df_state to the function
        content_type_radio,
        release_year_slider,
        country_multiselect,
        rating_multiselect,
        genre_multiselect
    ]
    filter_outputs_for_change = [
        filtered_df_state, # Update the filtered_df_state
        filtered_data_display,
        filtered_count_display,
        plot_type_dist,
        plot_rating_dist,
        plot_top_countries_chart,
        plot_content_added_chart,
        plot_top_genres_chart,
        plot_movie_duration_chart
    ]

    content_type_radio.change(update_dashboard, filter_inputs_for_change, filter_outputs_for_change)
    release_year_slider.change(update_dashboard, filter_inputs_for_change, filter_outputs_for_change)
    country_multiselect.change(update_dashboard, filter_inputs_for_change, filter_outputs_for_change)
    rating_multiselect.change(update_dashboard, filter_inputs_for_change, filter_outputs_for_change)
    genre_multiselect.change(update_dashboard, filter_inputs_for_change, filter_outputs_for_change)

# Launch the Gradio application
# share=True generates a public link accessible from anywhere, perfect for Colab
demo.launch(share=True)